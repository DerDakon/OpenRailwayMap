/*
OpenRailwayMap Copyright (C) 2012 Alexander Matheisen
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it under certain conditions.
See http://wiki.openstreetmap.org/wiki/OpenRailwayMap for details.
*/


var cluster = require('cluster');
var os = require('os');
var rbush = require('rbush');
var assert = require('assert');
var http = require("http");
var url = require("url");
var mkdirp = require('mkdirp');
var pg = require('pg');
var byline = require('byline');
var log4js = require('log4js');


var Canvas = require('canvas');
Image = Canvas.Image;


var events = require('events');
eventEmitter = new events.EventEmitter();


// tag conditions for faster database queries, smaller tiles and faster rendering
// conditions are hardcoded for better results, but could also be generated by a stylefile parser
var condition = new Array();
condition[0] = "AND (tags->'usage'='main')";
condition[1] = "AND (tags->'usage'='main')";
condition[2] = "AND (tags->'usage'='main')";
condition[3] = "AND (tags->'usage'='main')";
condition[4] = "AND (tags->'usage'='main')";
condition[5] = "AND (tags->'usage'='main')";
condition[6] = "AND (tags->'usage'='main')";
condition[7] = "AND (tags->'usage'='main')";
condition[8] = "AND ((tags->'usage'='main') OR (tags->'usage'='branch'))";
condition[9] = "AND ((tags->'usage'='main') OR (tags->'usage'='branch') OR (tags->'railway'='disused') OR (tags->'railway'='abandoned') OR (tags->'railway'='proposed') OR (tags->'railway'='construction') OR (tags->'railway'='station') OR (tags->'railway'='narrow_gauge'))";
condition[10] = "AND ((tags->'railway'='rail') OR (tags->'railway'='disused') OR (tags->'railway'='abandoned') OR (tags->'railway'='proposed') OR (tags->'railway'='construction') OR (tags->'railway'='light_rail') OR (tags->'railway'='tram') OR (tags->'railway'='subway') OR (tags->'railway'='narrow_gauge') OR (tags->'railway'='station') OR (tags->'railway'='halt'))";


// size of tiles in pixels
var tileSize = 256;
// relative or absolute path to the vector tile directory
var vtiledir = "../tiles";
// relative or absolute path to the bitmap tile directory
var tiledir = "../bitmap-tiles";
// path to the list of expired tiles
var expiredtilesdir = "../../olm/import";
// relative or absolute path to the directory of the required scripts
var scriptdir = "../js/";
// zoom offset
var zoomOffset = 0;
// minimal and maximal zoom level
var minZoom = 2;
var maxZoom = 22;
// list of existing rendering styles
var styles = new Array("standard", "maxspeed", "signals");
// scale fector used for vector tiling
var intscalefactor = 10000;
// name of geometry column
var geomcolumn = "way";
// prefix of osm2pgsql tables
var prefix = "railmap";
// name of database
var db = "railmap";
// number of cpus
var cpus = os.cpus().length;
// pixel tolerance used for getting vector data
var pxtolerance = 1.8;
// highest zoomlevel in which tiles are prerendered; tiles in higher zoomlevels will just be removed from cache if expired
var maxprerender = 12;


// include necessary libraries
logger.trace('Including KothicJS...');
eval(fs.readFileSync(scriptdir+'kothic.js')+'');
eval(fs.readFileSync(scriptdir+'renderer/path.js')+'');
eval(fs.readFileSync(scriptdir+'renderer/line.js')+'');
eval(fs.readFileSync(scriptdir+'renderer/polygon.js')+'');
eval(fs.readFileSync(scriptdir+'renderer/shields.js')+'');
eval(fs.readFileSync(scriptdir+'renderer/path.js')+'');
eval(fs.readFileSync(scriptdir+'renderer/texticons.js')+'');
eval(fs.readFileSync(scriptdir+'renderer/path.js')+'');
eval(fs.readFileSync(scriptdir+'renderer/text.js')+'');
eval(fs.readFileSync(scriptdir+'style/mapcss.js')+'');
eval(fs.readFileSync(scriptdir+'style/style.js')+'');
eval(fs.readFileSync(scriptdir+'utils/collisions.js')+'');
eval(fs.readFileSync(scriptdir+'utils/geom.js')+'');
eval(fs.readFileSync(scriptdir+'utils/collisions.js')+'');
logger.trace('KothicJS loaded.');


// workaround to emulate browser properties
var window = new Object;
window.devicePixelRatio = 1;
// workaround to emulate browser frame method
window.requestAnimationFrame = (
	function()
	{
		return function(callback)
		{
			callback();
		};
	}
)();
// workaround to emulate dom functions
var document = new Object;
document.createElement = function()
{
	return new Canvas();
}


// renders a certain tile and calls the callback with the ready-rendered canvas when finished
function renderTile(zoom, x, y, styleName, features, callback)
{
	logger.debug('z'+zoom+'x'+x+'y'+y+' Rendering data...');

	// start bitmap rendering
	var canvas = new Canvas(tileSize, tileSize);
	canvas.style = new Object();
	invertYAxe(features);

	MapCSS.invalidateCache();
	MapCSS.availableStyles.length = 0;
	MapCSS.availableStyles.push(styleName);

	Kothic.render(canvas, features, parseInt(zoom)+zoomOffset,
	{
		styles: MapCSS.availableStyles,
		onRenderComplete: function()
		{
			logger.debug('z'+zoom+'x'+x+'y'+y+' Finished rendering bitmap tile.');
			return process.nextTick(function()
			{
				callback(false, canvas);
			});
		}
	});
}


// requests objects for a certain tile and returns the data as an object
function getVectorData(x, y, z, callback)
{
	x = parseInt(x);
	y = parseInt(y);
	z = parseInt(z);
	var bbox = bboxByTile(z+1, x, y);
	var bbox_p = from4326To900913(bbox);
	var zoom = z+2;

	var connection = "postgres://postgres@localhost/railmap";
	var content = new Object();
	content.features = new Array();
	var client = new pg.Client(connection);

	logger.debug('z'+z+'x'+x+'y'+y+' Connecting to database '+connection+'...');
	client.connect(function(err)
	{
		if (err)
		{
			logger.error('z'+z+'x'+x+'y'+y+' Connection to database '+connection+' failed. Returning.');
			return process.nextTick(function()
			{
				callback(err, null);
			});
		}
		else
			logger.debug('z'+z+'x'+x+'y'+y+' Connected to database.');

		// request polygons
		var query = getDatabaseQuery("polygon", bbox_p, zoom);
		logger.trace('z'+z+'x'+x+'y'+y+' Requesting polygons...');
		client.query(query, function(err, polygons)
		{
			var features = getJSONFeatures(polygons.rows);
			// request lines
			var query = getDatabaseQuery("line", bbox_p, zoom);
			logger.trace('z'+z+'x'+x+'y'+y+' Requesting lines...');
			client.query(query, function(err, lines)
			{
				features = features.concat(getJSONFeatures(lines.rows));
				// request points
				var query = getDatabaseQuery("point", bbox_p, zoom);
				logger.trace('z'+z+'x'+x+'y'+y+' Requesting points...');
				client.query(query, function(err, points)
				{
					logger.trace('z'+z+'x'+x+'y'+y+' All database queries finished, generating JSON data object.');
					content.features = features.concat(getJSONFeatures(points.rows));
					// catch tiles without data
					if (!content.features)
					{
						content.features = new Array();
						logger.debug('z'+z+'x'+x+'y'+y+' Vector tile contains no data.');
					}
			
					content.granularity = intscalefactor;
					content.bbox = bbox;
					client.end();
					logger.debug('z'+z+'x'+x+'y'+y+' Generated vector data.');
					return process.nextTick(function()
					{
						callback(err, content);
					});
				});
			});
		});
	});
}


// converts raw JSON features from database response to objects
function getJSONFeatures(rows)
{
	var features = new Array();
	for (var i=0; i<rows.length; i++)
	{
		var geojson = JSON.parse(rows[i][geomcolumn]);
		if (geojson.type == "GeometryCollection")
			continue;
		if (geojson.reprpoint)
			geojson.reprpoint = JSON.parse(rows[i].reprpoint.coordinates);
		geojson.properties = JSON.parse(rows[i].tags);
		features.push(geojson);
	}
	return features;
}


// stores a vector tile in the vector tile directory
function saveVectorTile(data, x, y, z, callback)
{
	var filepath = vtiledir+'/'+z+'/'+x;
	logger.debug('z'+z+'x'+x+'y'+y+' Creating path '+filepath+'...');
	mkdirp(filepath, function(err)
	{
		if (err)
		{
			logger.error('z'+z+'x'+x+'y'+y+' Cannot create path: '+filepath+'. Returning.');
			return process.nextTick(function()
			{
				callback(err);
			});
		}

		logger.debug('z'+z+'x'+x+'y'+y+' Created path. Saving vector tile at path: '+filepath+'/'+y+'.json');
		fs.writeFile(filepath+'/'+y+'.json', data, {mode: 0777}, function(err)
		{
			if (err)
			{
				logger.error('z'+z+'x'+x+'y'+y+' Cannot save vector tile at path: '+filepath+'/'+y+'.json');
				return process.nextTick(function()
				{
					callback(err);
				});
			}

			logger.debug('z'+z+'x'+x+'y'+y+' Saved vector tile at path: '+filepath+'/'+y+'.json');
			return process.nextTick(function()
			{
				callback(false);
			});
		});
	});
}


// returns a database sql query string
function getDatabaseQuery(type, bbox, zoom)
{
	var cond = condition[zoom] || "";
	if (type == "polygon")
	{
		return "\
					SELECT\
						ST_AsGeoJSON(ST_TransScale(ST_ForceRHR(ST_Intersection(way, SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913))), "+(-bbox[0])+", "+(-bbox[1])+", "+intscalefactor/(bbox[2]-bbox[0])+", "+intscalefactor/(bbox[3]-bbox[1])+"), 0) AS "+geomcolumn+",\
						hstore2json(CAST(hstore(tags) AS hstore)) AS tags,\
						ST_AsGeoJSON(ST_TransScale(ST_ForceRHR(ST_PointOnSurface(way)), "+(-bbox[0])+", "+(-bbox[1])+", "+intscalefactor/(bbox[2]-bbox[0])+", "+intscalefactor/(bbox[3]-bbox[1])+"), 0) AS reprpoint\
					FROM\
						(\
							SELECT (ST_Dump(ST_Multi(ST_SimplifyPreserveTopology(ST_Buffer(way ,-"+pixelSizeAtZoom(zoom, pxtolerance)+"), "+pixelSizeAtZoom(zoom, pxtolerance)+")))).geom AS "+geomcolumn+", tags\
							FROM\
								(\
									SELECT ST_Union(way) AS "+geomcolumn+", tags\
									FROM\
										(\
											SELECT ST_Buffer(way, "+pixelSizeAtZoom(zoom, pxtolerance)+") AS "+geomcolumn+", CAST(tags AS text) AS tags\
											FROM "+prefix+"_polygon\
											WHERE way && SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913) AND way_area > "+(Math.pow(pixelSizeAtZoom(zoom, pxtolerance), 2)/pxtolerance)+" "+cond+"\
										) p\
									GROUP BY CAST(tags AS text)\
								) p\
							WHERE ST_Area(way) > "+Math.pow(pixelSizeAtZoom(zoom, pxtolerance), 2)+"\
							ORDER BY ST_Area(way)\
						) p";
	}
	else if (type == "line")
	{
		return "\
					SELECT\
						ST_AsGeoJSON(ST_TransScale(ST_Intersection(way, SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913)), "+(-bbox[0])+", "+(-bbox[1])+", "+(intscalefactor/(bbox[2]-bbox[0]))+", "+(intscalefactor/(bbox[3]-bbox[1]))+"), 0) AS "+geomcolumn+", hstore2json(CAST(hstore(tags) AS hstore)) as tags\
					FROM\
						(\
							SELECT (ST_Dump(ST_Multi(ST_SimplifyPreserveTopology(ST_LineMerge(way), "+pixelSizeAtZoom(zoom, pxtolerance)+")))).geom AS "+geomcolumn+", tags\
							FROM\
								(\
									SELECT ST_Union(way) AS "+geomcolumn+", CAST(tags AS text)\
									FROM "+prefix+"_line\
									WHERE way && SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913) "+cond+"\
									GROUP BY CAST(tags AS text)\
								) p\
						) p";
	}
	else if (type == "point")
	{
		return "\
					SELECT ST_AsGeoJSON(ST_TransScale(way, "+(-bbox[0])+", "+(-bbox[1])+", "+(intscalefactor/(bbox[2]-bbox[0]))+", "+(intscalefactor/(bbox[3]-bbox[1]))+"), 0) AS "+geomcolumn+", hstore2json(tags) AS tags\
					FROM "+prefix+"_point\
					WHERE\
			        way && SetSRID('BOX3D("+bbox[0]+" "+bbox[1]+","+bbox[2]+" "+bbox[3]+")'::box3d, 900913) "+cond+"\
					LIMIT 10000";
	}
}


// equivalent of tanh in PHP
function tanh(i)
{
	return (Math.exp(i) - Math.exp(-i)) / (Math.exp(i) + Math.exp(-i));
}


// equivalent of rad2deg in PHP
function rad2deg(angle)
{
	return angle/(Math.PI/180.0);
}


// equivalent of deg2rad in PHP
function deg2rad(angle)
{
	return angle*(Math.PI/180.0);
}


// adds a callback function to the data to make it usable for browser rendering
function getVectorDataString(data, x, y, z)
{
	return "onKothicDataResponse("+data+","+z+","+x+","+y+");";
}


// Wrapper around transform call for convenience. Transforms line from EPSG:900913 to EPSG:4326
// line - a list of [lat0,lon0,lat1,lon1,...] or [(lat0,lon0),(lat1,lon1),...]
function from900913To4326(line)
{
	var serial = false;
	if (!Array.isArray(line[0]))
	{
		serial = true;
		var l1 = new Array();
		for (var i=0; i<line.length; i=i+2)
			l1.push(new Array(line[i], line[i+1]));
		line = l1;
	}
	var ans = new Array();
	for (var i=0; i<line.length; i++)
	{
		var xtile = line[i][0]/111319.49079327358;
		var ytile = rad2deg(Math.asin(tanh(line[i][1]/20037508.342789244*Math.PI)));
		if (serial)
		{
			ans.push(xtile);
			ans.push(ytile);
		}
		else
			ans.push(new Array(xtile, ytile));
	}
	return ans;
}


// Wrapper around transform call for convenience. Transforms line from EPSG:4326 to EPSG:900913
// line - a list of [lat0,lon0,lat1,lon1,...] or [(lat0,lon0),(lat1,lon1),...]
function from4326To900913(line)
{
	var serial = false;
	if (!Array.isArray(line[0]))
	{
		serial = true;
		var l1 = new Array();
		for (var i=0; i<line.length; i=i+2)
			l1.push(new Array(line[i], line[i+1]));
		var line = l1;
	}

	var ans = new Array();
	for (var i=0; i<line.length; i++)
	{
		var latRad = deg2rad(line[i][1]);
	  	var xtile = line[i][0]*111319.49079327358;
	  	var ytile = Math.log(Math.tan(latRad) + (1 / Math.cos(latRad))) / Math.PI * 20037508.342789244;

		if (serial)
		{
			ans.push(xtile);
			ans.push(ytile);
		}
		else
			ans.push(new Array(xtile, ytile));
	}

	return ans;
}


// returns the content of a vector tile as a string
function readVectorTile(x, y, z, callback)
{
	var path = vtiledir+'/'+z+'/'+x+'/'+y+'.json';
	logger.debug('z'+z+'x'+x+'y'+y+' Reading vector tile at path: '+path);
	fs.readFile(path, function(err, data)
	{
		if (!err && data)
		{
			logger.debug('z'+z+'x'+x+'y'+y+' Loaded data from vector tile: '+path);
			return process.nextTick(function()
			{
				callback(err, JSON.parse(data));
			});
		}
		else
		{
			logger.debug('z'+z+'x'+x+'y'+y+' Cannot read vector tile: '+path);
			return process.nextTick(function()
			{
				callback(err, null);
			});
		}
	});
}


// helper function to invert the y axe of the data
function invertYAxe(data)
{
	var type, coordinates, tileSize = data.granularity, i, j, k, l, feature;

	for (i = 0; i < data.features.length; i++)
	{
	    feature = data.features[i];
	    coordinates = feature.coordinates;
	    type = data.features[i].type;
	    if (type === 'Point')
	        coordinates[1] = tileSize - coordinates[1];
		else if (type === 'MultiPoint' || type === 'LineString')
	        for (j = 0; j < coordinates.length; j++) 
	            coordinates[j][1] = tileSize - coordinates[j][1];
		else if (type === 'MultiLineString' || type === 'Polygon')
	        for (k = 0; k < coordinates.length; k++)
	            for (j = 0; j < coordinates[k].length; j++)
	                coordinates[k][j][1] = tileSize - coordinates[k][j][1];
		else if (type === 'MultiPolygon')
	        for (l = 0; l < coordinates.length; l++)
	            for (k = 0; k < coordinates[l].length; k++)
	                for (j = 0; j < coordinates[l][k].length; j++)
	                    coordinates[l][k][j][1] = tileSize - coordinates[l][k][j][1];
		else
	        throw "Unexpected GeoJSON type: " + type;

	    if (feature.hasOwnProperty('reprpoint'))
	        feature.reprpoint[1] = tileSize - feature.reprpoint[1];
	}
}


// Converts l pixels on tiles into length on zoom z
function pixelSizeAtZoom(z, l)
{
	l = l || 1;
	return l*20037508.342789244 / 256*2 / Math.pow(2, z);
}


// Tile numbers of given zoom level to EPSG:4326 bbox of a tile
function bboxByTile(z, x, y)
{
	var a = coordsByTile(z, x, y);
	var b = coordsByTile(z, x+1, y+1);
	return new Array(a[0], b[1], b[0], a[1]);
}


// Converts (z,x,y) to coordinates of corner of a tile
function coordsByTile(z, x, y)
{
	z = z-1;
	var normalizedTile = new Array(x/Math.pow(2.0, z), 1.0-(y/Math.pow(2.0, z)));
	var projectedBounds = from4326To900913(new Array(-180.0, -85.0511287798, 180.0, 85.0511287798));
	var maxp = new Array(projectedBounds[2]-projectedBounds[0], projectedBounds[3]-projectedBounds[1]);
	var projectedCoords = new Array((normalizedTile[0]*maxp[0])+projectedBounds[0], (normalizedTile[1]*maxp[1])+projectedBounds[1]);
	return from900913To4326(projectedCoords);
}


// add a tile to the queue
function addTileToQueue(z, x, y)
{
	queue.push(new Array(z, x, y));
}


// render all tiles on initial run
function initQueue()
{
	var z = minZoom;
	var x = 0;
	var y = -1;
	var tilecount = Math.pow(2, z);

	// removes a tile from the queue if rendered and renders the next tile
	var initTileFinished = function renderNextTileInit()
	{
		logger.debug('Checking system load... ');
		if (os.loadavg()[0] <= cpus+1)
		{
			if (y < tilecount-1)
				y++;
			else
			{
				if (x < tilecount-1)
				{
					x++;
					y = 0;
				}
				else if (z < maxprerender)
				{
					z++;
					tilecount = Math.pow(2, z);
					x = 0;
					y = 0;
				}
				else
				{
					logger.info('All tiles rendered. Finished.');
					return;
				}
			}
			logger.debug('Rendering next tile...');
			var tile = new Array(z, x, y);
			renderQueueElement(tile);
		}
		else
		{
			logger.info('System load too high, will retry after 5 seconds...');
			setTimeout(function()
			{
				eventEmitter.emit('tileFinished');
			}, 5000);
		}
	}
	eventEmitter.on('tileFinished', initTileFinished);

	eventEmitter.emit('tileFinished');
}


// render all tiles that are in the queue
function renderQueue()
{
	// removes a tile from the queue if rendered and renders the next tile
	var tileFinished = function renderNextTile()
	{
		if (queue.length != 0)
		{
			logger.debug('Checking system load...');
			if (os.loadavg()[0] <= cpus+1)
			{
				logger.debug('Rendering next tile in the queue...');
				var tile = queue.shift();
				renderQueueElement(tile);
			}
			else
			{
				logger.info('System load too high, will retry after 5 seconds...');
				setTimeout(function()
				{
					eventEmitter.emit('tileFinished');
				}, 5000);
			}
		}
		else
			logger.info('All tiles rerendered. Queue empty.');
	}
	eventEmitter.on('tileFinished', tileFinished);

	eventEmitter.emit('tileFinished');
}


// take one tile from the queue and render it
function renderQueueElement(tile)
{
	var zoom = tile[0];
	var x = tile[1];
	var y = tile[2];

	logger.info('z'+zoom+'x'+x+'y'+y+' Rendering tile from the queue.');
	logger.debug('z'+zoom+'x'+x+'y'+y+' Getting vector data...');
	getVectorData(x, y, zoom, function(err, data)
	{
		if (err)
		{
			logger.info('z'+zoom+'x'+x+'y'+y+' Vectortile could not be created. Aborting.');
			eventEmitter.emit('tileFinished');
			return;
		}

		logger.debug('z'+zoom+'x'+x+'y'+y+' Vector data loaded, saving vector tile...');
		saveVectorTile(JSON.stringify(data), x, y, zoom, function(err)
		{
			if (err)
			{
				logger.warn('z'+zoom+'x'+x+'y'+y+' Vector tile could not be saved. Returning.');
				eventEmitter.emit('tileFinished');
				return;
			}

			// render standard layer only
			logger.debug('z'+zoom+'x'+x+'y'+y+' Vector tile saved, rendering bitmap tile...');
			var selectedStyle = 0;
			MapCSS.onImagesLoad = function()
			{
				logger.trace('z'+zoom+'x'+x+'y'+y+' MapCSS style loaded.');
				var filepath = tiledir+'/'+styles[selectedStyle]+'/'+zoom+'/'+x;
				renderTile(zoom, x, y, styles[selectedStyle], data, function(err, image)
				{
					if (err)
					{
						logger.warn('z'+zoom+'x'+x+'y'+y+' Bitmap tile could not be rendered. Returning.');
						eventEmitter.emit('tileFinished');
						return;
					}

					logger.debug('z'+zoom+'x'+x+'y'+y+' Bitmap tile successfully rendered.');
					logger.debug('z'+zoom+'x'+x+'y'+y+' Creating path '+filepath+'...');
					mkdirp(filepath, function(err)
					{
						if (err)
						{
							logger.error('z'+zoom+'x'+x+'y'+y+' Cannot create path '+filepath+'. Returning.');
							eventEmitter.emit('tileFinished');
							return;
						}

						logger.error('z'+zoom+'x'+x+'y'+y+' Saving bitmap tile at path: '+filepath+'/'+y+'.png');
						var out = fs.createWriteStream(filepath+'/'+y+'.png', {mode: 0777});
						var stream = image.createPNGStream();

						// write PNG data stream
						stream.on('data', function(data)
						{
							out.write(data);
						});

						// PNG data stream ended
						stream.on('end', function()
						{
							logger.debug('z'+zoom+'x'+x+'y'+y+' Bitmap tile was saved.');

							// remove tile from queue and render next tile if every style was rendered
							logger.debug('z'+zoom+'x'+x+'y'+y+' Finished. Getting the next tile from the queue...');
							eventEmitter.emit('tileFinished');
						});
					});
				});
			}
			// load map icons
			MapCSS.preloadSpriteImage(styles[selectedStyle], "../styles/"+styles[selectedStyle]+".png");
		});
	});
}


// load an osm2pgsql list of expired tiles to the queue
function addExpiredTilesToQueue(filename, callback)
{
	logger.debug('Checking if list of expired tiles exists...');
	fs.exists(expiredtilesdir+'/'+filename, function(exists)
	{
		if (exists)
		{
			logger.info('Reading list of expired tiles...');
			var stream = byline(fs.createReadStream(expiredtilesdir+'/'+filename));
			stream.on('data', function(line)
			{
				var tile = line.toString().split("/");

				// remove cached tiles
				if (tile[0] > maxprerender)
				{
					for (var s=0; s<styles.length; s++)
					{
						var filepath = tiledir+'/'+styles[s]+'/'+tile[0]+'/'+tile[1];
						logger.debug('Removing bitmap tile '+filepath+'/'+tile[2]+'.png ...');
						fs.unlink(filepath+'/'+tile[2]+'.png', function(err)
						{
							if (err)
								logger.error('Could not remove bitmap tile: '+filepath+'/'+tile[2]+'.png');
							else
								logger.debug('Successfully removed bitmap tile: '+filepath+'/'+tile[2]+'.png');
						});
					}
				}
				// prerender lowzoom tiles only
				else
					addTileToQueue(tile[0], tile[1], tile[2]);
			});
			stream.on('end', function(line)
			{
				logger.info('Expired tiles successfully added to the queue.');
				return process.nextTick(function()
				{
					callback(false);
				});
			});
			stream.on('error', function(line)
			{
				logger.error('Cannot read list of expired tiles. Aborting.');
				return process.nextTick(function()
				{
					callback(true);
				});
			});
		}
		else
			logger.error('Cannot find expired-tiles-file. Aborting.');
	});
}
